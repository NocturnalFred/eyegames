<!DOCTYPE html>
<html >
<body bgcolor="#FFFFF">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>

<div >
<canvas id="myCanvas" width="1040" height="1000" style="border:1px solid #c3c3c3;position: fixed;left: 50%;margin-left: -520px;">
Your browser does not support the HTML5 canvas tag.
</canvas>
</div>
<script>

var intersection = function(R1, R2, width) {

var p = (R1 + R2 + width)/2;
var area = Math.sqrt(p*(p-R1)*(p-R2)*(p-width));
var h = (2*area/width);
var x = (Math.sqrt(Math.pow(R1, 2) - Math.pow(h,2)));
var arr = [x,h];
return arr;

}

function generateArc(R1, R2, width) {

}

//the eCircle class takes in a factor for the size of the circle, the name of the canvas, and 
//starting x and y locs for the cooridinates of the circles.
var PolyGon = PolyGon || function(context, color, PointArray)
{
	this.POINTS = PointArray;
	this.color = color;
	this.contxt = document.getElementById(context).getContext("2d");

	this.draw = function()
	{
		POINTS = this.POINTS;
		this.contxt.strokeStyle=this.color;	
		this.contxt.fillStyle=this.color;	
		this.contxt.lineWidth=2;
		this.contxt.beginPath();
		this.contxt.moveTo(POINTS[0][0], POINTS[0][1]);
		for (var a=1; a < POINTS.length; ++a)
		{
			this.contxt.lineTo(POINTS[a][0], POINTS[a][1]);
		}
		
		this.contxt.stroke();
		this.contxt.closePath();
		this.contxt.fill();
		
	}

};


var baseCircle = baseCircle || function(x, y, r, c, w, contxt) {

	
	/*
		X cooridinate
		Y Cooridinate
		radius
		color
	*/
	//To cut down on typing I'm using single letter variables.
	//X,Y, and R are obvious.
	//C = color
	//W = line width
	//contxt = the contxt of the html canvas that needs to be passed in so you can draw to it.
	this.X = x;
	this.Y = y;
	this.R = r;
	this.C = c;
	this.W = w;
	this.contxt = document.getElementById(contxt).getContext("2d");

	
	this.draw = function() {
	 //	    var ctx1 = document.getElementById(contxt).getContext("2d");
	 // 	var ctx2 = document.getElementById(contxt).getContext("2d");  
		this.contxt.globalAlpha=.9;
		this.contxt.strokeStyle=this.C;
		this.contxt.lineWidth=this.W;

		this.contxt.beginPath();
		this.contxt.arc(this.X,this.Y,this.R,0,2*Math.PI);
		this.contxt.stroke();
		this.contxt.closePath();
	}
	this.clear = function() {
		this.contxt.clearRect(0, 0, 500, 1000);
	}
};

var anagCircle = anagCircle || function(x, y, r, c, w, contxt, width) {
	this.findAnX = function (x,width) {  //canvas sees left circle as base location
		return x - width/2 ;
	
	}
	this.X = this.findAnX(x,width);
	this.Y = y;
	this.R = r;
	this.W = w;
	this.context=contxt;
	this.contxt = document.getElementById(contxt).getContext("2d");
	this.width = width;
	left = new baseCircle(this.X, this.Y, this.R, "#F20", this.W, contxt);
	right = new baseCircle(this.X + this.width, this.Y, this.R, "#00FFFF", this.W, contxt);
	
	

	
	this.draw = function() {
	console.log("drawing");
		right.draw();	
		left.draw();
		
		var top = new Array();
		var bottom = new Array();
		//Start with the inner widths, increaseing the width for one side.
		for (var a = 1; a < this.W; a++)
		{
			var info = intersection(this.R+this.W/2, this.R-this.W/2+a, this.width);
			var info2 = intersection(this.R+this.W/2, this.R-this.W/2+a, this.width);
			info[0] = this.X + info[0];
			info[1] = this.Y + info[1]-1;
			top.push(info);
 
			info2[0] = this.X + info2[0];
			info2[1] = this.Y - info2[1]+1;
			bottom.push(info2);
			
		}
		
		for (var a = 1; a < this.W; a++)
		{
			var info = intersection(this.R+this.W/2-a, this.R+this.W/2, this.width);
			var info2 = intersection(this.R+this.W/2-a, this.R+this.W/2, this.width);
			info[0] = this.X + info[0];
			info[1] = this.Y + info[1]-1;
			top.push(info);
 
			info2[0] = this.X + info2[0];
			info2[1] = this.Y - info2[1]+1;
			bottom.push(info2);
			
		}
		for (var a = 1; a < this.W; a++)
		{
			var info = intersection(this.R-this.W/2, this.R+this.W/2-a, this.width);
			var info2 = intersection(this.R-this.W/2, this.R+this.W/2-a, this.width);
			info[0] = this.X + info[0];
			info[1] = this.Y + info[1]+1;
			top.push(info);
 
			info2[0] = this.X + info2[0];
			info2[1] = this.Y - info2[1]-1;
			bottom.push(info2);
			
		
		}
		for (var a = 1; a < this.W; a++)
		{
			var info = intersection(this.R-this.W/2+a, this.R-this.W/2, this.width);
			var info2 = intersection(this.R-this.W/2+a, this.R-this.W/2, this.width);			
			info[0] = this.X + info[0];
			info[1] = this.Y + info[1]+1;
			top.push(info);
 
			info2[0] = this.X + info2[0];
			info2[1] = this.Y - info2[1]-1;
			bottom.push(info2);
			
		}


		
		var poly = new PolyGon(this.context, "#222", top);
		var poly2 = new PolyGon(this.context, "#333", bottom);
		poly.draw();
		poly2.draw();



	}
};

//four circles, left, right, top, bottom
//randomized distances, make sure the one that is the "correct" answer isn't the same as any of hte others.

//lets store the circles in an array, top = 0, left =1, right =2, and bottom =3 



//Choose correct circle.
var correct = 0;
var newGame = function () {

	var clear = document.getElementById("myCanvas").getContext("2d");
	clear.clearRect(0, 0, 1040, 1000);

	var T = new Date().getSeconds();
	correct = T % 4;

	var theSame = true;  //sentinel to check that "answer" and the rest of the circles are not the same.
	var minWidth = 40;
	var maxWidth = 160;
	var difference = maxWidth - minWidth;

	var widthArray = new Array();

	for (var i = 0; i < 4; i++)
	{
		widthArray.push(Math.ceil(difference*Math.random() + 40));
		console.log(i);
			console.log(widthArray[i]);
	}

	var i = 0;

	while(i < 4)
	{
		if ( Math.abs(widthArray[correct] - widthArray[i]) <= 10 && i != correct)
		{
			widthArray[i] = Math.ceil(difference*Math.random()) + 40;

		} else {
			i++;
		}
	}

	var middleY = 315;
	var top = new anagCircle(530, 110, 90, "ffA100", 10, "myCanvas", widthArray[0]); 

	top.draw();
	var bottom = new anagCircle(530, 520, 90, "ffA100", 10, "myCanvas", widthArray[3]);

	bottom.draw();
	var middle = new anagCircle(530, middleY, 90, "ffA100", 10, "myCanvas", widthArray[correct]);

	middle.draw();

	//take width from "middle" which will be the widht of the "correct" circle and use base of 530 as the beginning 
	//for the "x" cooridante you need for the left and right sides.

	var distanceFromCenter = (90 + widthArray[correct]/2);
	var rightLengthOfLeft = (105 + widthArray[1]/2);
	var leftLengthOfRight = (105 + widthArray[2]/2);
	var left = new anagCircle(530 - distanceFromCenter - rightLengthOfLeft, middleY, 90, "ffA100", 10, "myCanvas", widthArray[1]); 

	left.draw();
	var right = new anagCircle(530 + distanceFromCenter + leftLengthOfRight, middleY, 90, "ffA100", 10, "myCanvas", widthArray[2]); 

	right.draw();
		


	//genuine center is 400.  Thus I must calculate an "X" to give the middle circle
	//such that the whole thing will appear to be in the center.
	//No fuck that, I'm going to have the anaglyph function take the true "center" and then
	//do math to identify the proper x for that center.




}

 newGame();


function checkCorrect(choice)
{
	if (choice == correct)
	{
		alert("correct");
		newGame();

		
		
	}
}


function keydown(ev) {

   // alert(ev.keyCode);


        switch(ev.keyCode) {		
			//up
          case 38:   checkCorrect(0);

		  break;
			//down
          case 40:   checkCorrect(3);
		  
		  break;
		  //right
		  case 39:	 checkCorrect(2);
		  
		  break;
		  //left
		  case 37:	 checkCorrect(1);
        }
 
    }
document.addEventListener('keydown', keydown, false);

</script>

</body>
</html>
